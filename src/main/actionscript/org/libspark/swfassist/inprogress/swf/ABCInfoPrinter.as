/* * The Spark Project ( http://libspark.org ) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. * * The Original Code is [Open Source Virtual Machine.]. * * The Initial Developer of the Original Code is Adobe System Incorporated. * Portions created by the Initial Developer are Copyright (C) 2004-2006 * the Initial Developer. All Rights Reserved. * * Contributor(s): * * Adobe AS3 Team * Mateusz Malczak ( http://segfaultlabs.com ) * Daniel Riley	 ( http://scientificsciences.com ) */package org.libspark.swfassist.inprogress.swf{import org.libspark.swfassist.swf.abc.structures.ABCMultinameInfo;import org.libspark.swfassist.swf.tags.AbstractTagVisitor;		//Dan	import org.libspark.swfassist.io.ByteArrayInputStream;	import org.libspark.swfassist.swf.tags.DoABC;		import org.libspark.swfassist.swf.abc.consts.ABCConsts;	import org.libspark.swfassist.swf.abc.structures.ABCClass;		import org.libspark.swfassist.swf.abc.structures.ABCInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInstance;	import org.libspark.swfassist.swf.abc.structures.ABCMetaData;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfo;	import org.libspark.swfassist.swf.abc.structures.ABCNamespace;	import org.libspark.swfassist.swf.abc.structures.ABCTraits;	import org.libspark.swfassist.swf.abc.structures.ABCTraitConstSlot;	import org.libspark.swfassist.swf.abc.structures.ABCTraitsInfo;		import org.libspark.swfassist.swf.abc.io.ABCReader;	import org.libspark.swfassist.swf.abc.io.ABCContext;	import org.libspark.swfassist.swf.abc.io.ABCReadingContext;	import org.libspark.swfassist.swf.abc.io.ABCPrintingContext;		import org.libspark.swfassist.swf.abc.opcode.ABCOpReader;		import flash.utils.getTimer;	import flash.events.Event;	import flash.display.Shape;		/**	 * This class asynchronously reads all DoABC tags and prints them out. It is	 * asynchronous because a huge DoABC tag could crash Flash Player	 */		public class ABCInfoPrinter extends AbstractTagVisitor	{		public function ABCInfoPrinter( context:ABCPrintingContext = null, timeLimit:uint = 0, onComplete:Function = null )		{			_timeLimit = timeLimit == 0 ? uint.MAX_VALUE : timeLimit;			_onComplete = onComplete;			printerContext = context = null ? new ABCPrintingContext() : context;		}				// Context used for deciding what aspects of the ABC to print		public var printerContext:ABCPrintingContext;				protected var indentValue:String = '';				protected var _thread:Shape;		protected var _onComplete:Function;				// Vars used for each tag read		public var reader:ABCReader;		public var readerContext:ABCReadingContext;		public var input:ByteArrayInputStream;		protected var _abcInfo:ABCInfo;				private var _tags:Vector.<DoABC>; 		// List of tags to be patched		private var _tag:uint = 0;				// Current tag index		private var _numTags:uint = 0;			// Number of tags to patch		private var _numTagsComplete:uint = 0; 	// Number of tags already patched				private var _timeLimit:uint = 0;				protected function print(...messages:Array):void		{			messages[0] = indentValue + messages[0];			trace.apply(null, messages);		}				protected function indent():void		{			indentValue += '  ';		}				protected function unindent():void		{			indentValue = indentValue.substr(0, -2);		}		public override function visitDoABC( tag:DoABC ):void		{			// Initialization			if( _tags == null )			{				_tags = new Vector.<DoABC>();				_numTags = 0;				_numTagsComplete = 0;			}						// Add the tag to a list of tags to process			_tags[ _numTags++ ] = tag;						// Process the first tag			if( _numTags == 1 )				printNextTag();						}				protected function printNextTag():void		{			var tag:DoABC = _tags[ _tag ];						_abcInfo = new ABCInfo();						reader = new ABCReader();						readerContext = new ABCReadingContext();			readerContext.methodBodyLimit = 500; //Read 500 method bodies per frame						input = new ByteArrayInputStream(tag.abcData);			input.position = 0;			// Start thread to read ABC, patch, and then write			if( _thread == null )				_thread = new Shape();							_thread.addEventListener(Event.ENTER_FRAME, readHandler);		}						/**		 * Called after a tag has been completely printed out. I then checks		 * if there is another tag on the stack to print, if not, it quits.		 */		private function printComplete():void		{			unindent();			print('</DoABC>');							if( ++_tag == _numTags )			{				if( _onComplete != null )					_onComplete();			} else {				printNextTag();			}		}				/**		 * Loop for parsing ABCInfo		 */		private function readHandler(e:Event):void		{			reader.readABC( input, readerContext, _abcInfo, _timeLimit );					if( readerContext.cursor == ABCContext.CURSOR_COMPLETE ) 			{				_thread.removeEventListener(Event.ENTER_FRAME, readHandler);				_thread.addEventListener(Event.ENTER_FRAME, printHandler);							}		}				private function printHandler(e:Event):void		{			visitABCInfo( _abcInfo, printerContext, _timeLimit );						if( printerContext.cursor == ABCContext.CURSOR_COMPLETE ) 			{				_thread.removeEventListener(Event.ENTER_FRAME, printHandler );				trace("done");			}		}				public function visitABCInfo( abcInfo:ABCInfo, context:ABCPrintingContext, maxTime:uint = 0 ):void		{			if( maxTime == 0 ) {				maxTime = uint.MAX_VALUE;			}					if( context.cursor == ABCContext.CURSOR_HEADER )			{				print('<DoABC>');					indent();			}						var startTime:uint = getTimer();			var complete:Boolean = context.cursor == ABCContext.CURSOR_COMPLETE;						while( !complete )			{				switch( context.cursor )				{					case ABCContext.CURSOR_HEADER:						visitHeader( abcInfo, context );						break;												case ABCContext.CURSOR_CPOOL:						visitCPool( abcInfo, context );						break;											case ABCContext.CURSOR_METHODS:						visitMethods( abcInfo, context );						break;											case ABCContext.CURSOR_METADATA:						visitMetaData( abcInfo, context );						break;										case ABCContext.CURSOR_INSTANCES:						visitInstances( abcInfo, context );						break;											case ABCContext.CURSOR_CLASSES:						visitClasses( abcInfo, context );						break;											case ABCContext.CURSOR_SCRIPTS:						visitScripts( abcInfo, context );						break;											case ABCContext.CURSOR_METHODBODIES:						// No need to print these because they will already be printed						// in the methods section						break;				}									// Read the next section of data or quit				context.updateCursor();								if( getTimer() - startTime > maxTime || context.cursor == ABCContext.CURSOR_COMPLETE ) {					complete = true;				}			}						if( context.cursor == ABCContext.CURSOR_COMPLETE )			{					unindent();				print('</ABCInfo>');			}		}				public function visitHeader( abcInfo:ABCInfo, context:ABCPrintingContext )		{			print('<ABCHeader>');			indent();				// TODO							unindent();			print('</ABCHeader>');		}				public function visitCPool( abcInfo:ABCInfo, context:ABCPrintingContext ):void		{			// return;			print('<ABCCPool>');			indent();								if( context.readNumbers )				{					print( "Ints: " + abcInfo.cpool.ints );					print( "UInts: " + abcInfo.cpool.uints );					print( "Doubles: " + abcInfo.cpool.doubles );				}								if( context.readStrings )				{					print( "Strings: " + abcInfo.cpool.strings );				}								if( context.readNamespaces )				{					visitNamespaces( abcInfo, context );				}						unindent();			print('</ABCCPool>');		}						public function visitNamespaces( abcInfo:ABCInfo, context:ABCPrintingContext ):void		{			print('<ABCNamespaces>');			indent();								var n:ABCNamespace;									for each( n in abcInfo.cpool.namespaces )					print( n.toString() + "::" );						unindent();			print('</ABCNamespaces>');		}				private function visitMethods( abcInfo:ABCInfo, context:ABCPrintingContext  )		{						if (context.methodLimit == 0) {				context.methodLimit = uint.MAX_VALUE;			}						if( context.methodCount == -1 ) {								print('<ABCMethods>');					indent();							context.methodCount = abcInfo.methods.length;			}						var i:int = -1;			while( ++i < context.methodLimit && (i + context.methodCursor) < context.methodCount )				visitMethod( abcInfo, context, abcInfo.getMethod(i+context.methodCursor) );						context.methodCursor += i;						if( context.methodCursor == context.methodCount )			{				unindent();				print('</ABCMethods>');			}					}				/**		 * Override this function to control how a method is printed		 */		public function visitMethod( abcInfo:ABCInfo, context:ABCPrintingContext, method:ABCMethodInfo ):void		{			print('<ABCMethod>');				indent();								if( !method.annonimous )				{					print(((method.flags & ABCConsts.NATIVE)?"native ":"") + ABCConsts.traitKinds[method.traitType] + " " + method.name + "(" + method.paramTypes + "):" + method.returnType + "\t/* disp_id " + method.id + "*/" );										if( context.readMethodCode )						visitMethodCode( abcInfo, method);				}							unindent();			print('</ABCMethod>');		}				public function visitMetaData( abcInfo:ABCInfo, context:ABCPrintingContext ):void		{			// return;			print('<ABCMetaData>');			indent();								for( var i:int = 0; i< abcInfo.metadata.length; i++ ) {										var md:ABCMetaData = abcInfo.metadata[i];										for( var n:String in md )							print( 'MetaData['+i+']['+n+'] = ' + md[n] );				}						unindent();			print('</ABCMetaData>');		}				public function visitInstances( abcInfo:ABCInfo, context:ABCPrintingContext )		{			// return;			print('<ABCInstances>');			indent();						var inst:ABCInstance;			var tr:ABCTraitsInfo;			var line:String;			var i:int;			/* dump all classes (instances) with traits (methods, variables, consts) */			for each (inst in abcInfo.instances) {								if (inst.flags & ABCConsts.CLASS_FLAG_interface)					line = "interface"				else {					line  = "class";					if ( !(inst.flags & ABCConsts.CLASS_FLAG_sealed) )						line = "dynamic " + line;					if ( inst.flags & ABCConsts.CLASS_FLAG_final )						line = "final " + line;				}							line += " " + inst.name + " extends " + inst.base;								if ( inst.interfaces.length > 0 ) {					line += " implements " + inst.interfaces[0];										for ( i = 1; i < inst.interfaces.length; i++)					 line += ", " + inst.interfaces[i];				}								print( line + " {");									if ( (inst.flags & 0x08 ) ) 					print(" /* protected namespace : "+ inst.protectedNs + "*/" );				 				if ( inst.init )					visitTraitsInfo( abcInfo, inst.init );				 				else 					print("/* no constructor code*/");								for each ( tr in inst.traits )					visitTraitsInfo( abcInfo, tr, context.readInstanceCode );				 											print("}");						}						unindent();			print('</ABCInstances>');		}						public function visitClasses( abcInfo:ABCInfo, context:ABCPrintingContext )		{			// return;			print('<ABCClasses>');			indent();						var c:ABCClass;			var traits:Array;			var tr:ABCTraitsInfo;						for each ( c in abcInfo.classes) {					print('Class ' + c.name + ' {');				indent();								print('Traits count: ' + c.traits.length );							traits = c.traits;				for each ( tr in traits )												visitTraitsInfo( abcInfo, tr );									visitTraitsInfo( abcInfo, c.init, context.readClassCode );								unindent();				print('}');			}						unindent();			print('</ABCClasses>');		}						public function visitScripts( abcInfo:ABCInfo, context:ABCPrintingContext ):void		{			// return;			print('<ABCScripts>');			indent();								var idx	:int = 0;				var t	:ABCTraits;				var tr	:ABCTraitsInfo;								for each ( t in abcInfo.scripts ) {											print( '<Script ' + (++idx) + '>');					indent();										for each ( tr in t.traits )						visitTraitsInfo( abcInfo, tr, context.readScriptCode );											visitTraitsInfo( abcInfo, t.init );											unindent();					print( '</Script ' + idx + '>');				}						unindent();			print('</ABCScripts>');		}		public function visitAnonymous( abcInfo:ABCInfo )		{			// return;			print('<ABCAnonymous>');			indent();						var i:int;			var meth:ABCMethodInfo;						for each ( meth in abcInfo.methods ){				if ( meth && meth.annonimous )					visitTraitsInfo( abcInfo, meth );			}									var done:Array = []			for (;;) {				var max:int = -1;				var maxsize:int = 0;								for (i=0; i < 256; i++) {										if (ABCConsts.opSizes[i] > maxsize && !done[i]) {						max = i;						maxsize = ABCConsts.opSizes[i];					}				}								if (max == -1)					break;				done[max] = 1;								print(ABCConsts.opNames[max]+"\t"+int(ABCConsts.opSizes[max]))			}						unindent();			print('</ABCAnonymous>');					}				public function visitTraitsInfo( abcInfo:ABCInfo, tInfo:ABCTraitsInfo, showCode:Boolean = false )		{			// return;			//print('<ABCTraitsInfo>');			indent();						if (tInfo.metadata)  {				print('<MetaData>');				indent();									for each (var md:* in tInfo.metadata)						print(md);										unindent();				print('</MetaData>');			}								switch( tInfo.kind & 0x0F )	{				case ABCConsts.TRAIT_Class:						print('Class ' + tInfo.name );					break;				case ABCConsts.TRAIT_Const:				case ABCConsts.TRAIT_Slot:					var trcs:ABCTraitConstSlot = tInfo as ABCTraitConstSlot;					print('Const/Slot ' + ABCConsts.traitKinds[trcs.kind] + " " + trcs.name + ":" + trcs.type + 							(trcs.value !== undefined ? (" = " + (trcs.value is String ? ('"'+trcs.value+'"') : trcs.value)) : "") + 							"\t/* slot_id " + trcs.id + " */" );					break;								case ABCConsts.TRAIT_Function:								case ABCConsts.TRAIT_Method:				case ABCConsts.TRAIT_Getter:				case ABCConsts.TRAIT_Setter:					var trm:ABCMethodInfo = tInfo as ABCMethodInfo;					print('Func/Meth/Get/Set ' + ((trm.flags & ABCConsts.NATIVE)?"native ":"") + ABCConsts.traitKinds[trm.kind & 0x0F] + " " + trm.name + "(" + trm.paramTypes + "):" + trm.returnType + "\t/* disp_id " + trm.id + "*/" );					if( showCode )						visitMethodCode( abcInfo, trm );					break;			}						unindent();			//print('</ABCTraitsInfo>');		}			public function visitMethodCode( abcInfo:ABCInfo, method:ABCMethodInfo ):void		{			// return;			print('<MethodCode>');			indent();							if ( method.body == null ) {				print('Code not available for method:' + method.name );			} else {																if (method.body.code == null) {					print('Can\'t read code:' + method.name );				} else {										var opReader:ABCOpReader = new ABCOpReader(method.body.code);						/*					if (flags & ABCConsts.NEED_ACTIVATION) {						abcInfo.logWriter.print(indent+"activation {")						activation.dump(ABCinfo, indent+ABCConsts.TAB, "")						abcInfo.logWriter.print(indent+"}")					}					*/										print( "// local_count="+method.body.localCount+						  " max_scope=" + method.body.maxScope +						  " max_stack=" + method.body.maxStack +						  " oplen=" + opReader.length) ;															var labels:ABCLabelInfo = new ABCLabelInfo();										var s:String;															while (opReader.bytesAvailable > 0) {						s = String(opReader.position);												while (s.length < 12) s += ' ';												opReader.read();										if (opReader.opCode == ABCConsts.OP_label || ((opReader.position-1) in labels)) {							indent();							print(labels.labelFor(opReader.position-1) + ": ");							unindent();						}										s += opReader.opCodeName;						s += opReader.opCodeName.length < 8 ? "\t\t" : "\t";													switch(opReader.opCode) {							case ABCConsts.OP_debugfile:							case ABCConsts.OP_pushstring:								s += '"' + abcInfo.cpool.getString(opReader.value[0]).replace(/\n/g,"\\n").replace(/\t/g,"\\t") + '"';								break;							case ABCConsts.OP_pushnamespace:								s += abcInfo.cpool.getNamespace(opReader.value[0]).name;								break;							case ABCConsts.OP_pushint:								var i:int = abcInfo.cpool.getInt(opReader.value[0]);								s += i + "\t// 0x" + i.toString(16);								break;							case ABCConsts.OP_pushuint:								var u:uint = abcInfo.cpool.getUInt(opReader.value[0]);								s += u + "\t// 0x" + u.toString(16);								break;							case ABCConsts.OP_pushdouble:								s += abcInfo.cpool.getDouble(opReader.value[0]);								break;							case ABCConsts.OP_getsuper: 							case ABCConsts.OP_setsuper: 							case ABCConsts.OP_getproperty: 							case ABCConsts.OP_initproperty: 							case ABCConsts.OP_setproperty: 							case ABCConsts.OP_getlex: 								//get value of a variable							case ABCConsts.OP_findpropstrict: 							case ABCConsts.OP_findproperty:							case ABCConsts.OP_finddef:							case ABCConsts.OP_deleteproperty: 							case ABCConsts.OP_istype: 							case ABCConsts.OP_coerce: 							case ABCConsts.OP_astype: 							case ABCConsts.OP_getdescendants:								var read:ABCMultinameInfo = abcInfo.cpool.getMultiname(opReader.value[0]);								//s += read.toString();																if( read.data.toString() != null ) {									s+= read.data.toString();								}								break;							case ABCConsts.OP_constructprop:							case ABCConsts.OP_callproperty:							case ABCConsts.OP_callproplex:							case ABCConsts.OP_callsuper:							case ABCConsts.OP_callsupervoid:							case ABCConsts.OP_callpropvoid:								s += abcInfo.cpool.getMultiname(opReader.value[0]);								s += " (" + opReader.value[1] + ")";								break;							case ABCConsts.OP_newfunction: //annonimous function, dump it in-place								var method_id:int = opReader.value[0];								s += abcInfo.getMethod(method_id).name;								abcInfo.getMethod(method_id).annonimous = true;								abcInfo.getMethod(method_id).kind = ABCConsts.TRAIT_Function;								print("ABCConsts.OP_newfunction");								print(s);								visitMethodCode( abcInfo, abcInfo.getMethod(method_id));  								//break;															continue;							case ABCConsts.OP_callstatic:								s += abcInfo.getMethod(opReader.value[0]).name;								s += " (" + opReader.value[1] + ")";								break;							case ABCConsts.OP_newclass: 								s += abcInfo.getInstance(opReader.value[0]).name;								break;							case ABCConsts.OP_lookupswitch:								var pos:int = opReader.position-1;								var target:int = pos + opReader.value[0];								var maxindex:int = opReader.value[1];								s += "default:" + labels.labelFor(target); // target + "("+(target-pos)+")"								s += " maxcase:" + maxindex;								for (i=0; i <= maxindex; i++) {									target = pos + opReader.value[2+i];									s += " " + labels.labelFor(target); // target + "("+(target-pos)+")"								}								break;							case ABCConsts.OP_jump:							case ABCConsts.OP_iftrue:		case ABCConsts.OP_iffalse:							case ABCConsts.OP_ifeq:		case ABCConsts.OP_ifne:							case ABCConsts.OP_ifge:		case ABCConsts.OP_ifnge:							case ABCConsts.OP_ifgt:		case ABCConsts.OP_ifngt:							case ABCConsts.OP_ifle:		case ABCConsts.OP_ifnle:							case ABCConsts.OP_iflt:		case ABCConsts.OP_ifnlt:							case ABCConsts.OP_ifstricteq:	case ABCConsts.OP_ifstrictne:								s += "Control Transfer ";								var offset:int = opReader.value[0];								target = opReader.position + offset;								s += target + " ("+offset+")"								s += labels.labelFor(target);								if (!(opReader.position in labels))									s += "\n";								break;							case ABCConsts.OP_inclocal:							case ABCConsts.OP_declocal:							case ABCConsts.OP_inclocal_i:							case ABCConsts.OP_declocal_i:							case ABCConsts.OP_getlocal:							case ABCConsts.OP_kill:							case ABCConsts.OP_setlocal:							case ABCConsts.OP_debugline:							case ABCConsts.OP_getglobalslot:							case ABCConsts.OP_getslot:							case ABCConsts.OP_setglobalslot:							case ABCConsts.OP_setslot:							case ABCConsts.OP_pushshort:							case ABCConsts.OP_newcatch:								s += opReader.value[0];								break;							case ABCConsts.OP_debug:								s += opReader.value[0];								s += " " + opReader.value[1];								s += " " + opReader.value[2];								s += " " + opReader.value[3];								break;							case ABCConsts.OP_newobject:								s += "{" + opReader.value[0] + "}";								break;							case ABCConsts.OP_newarray:								s += "[" + opReader.value[0] + "]";								break;							case ABCConsts.OP_call:							case ABCConsts.OP_construct:							case ABCConsts.OP_constructsuper:								s += "(" + opReader.value[0] + ")";								break;							case ABCConsts.OP_pushbyte:							case ABCConsts.OP_getscopeobject:								s += opReader.value[0]								break;							case ABCConsts.OP_hasnext2:								s += opReader.value[0] + " " + opReader.value[1];							default:								/*if (ABCConsts.opNames[opreader.swfutils::_dataInput] == ("0x"+opreader.swfutils::_dataInput.toString(16).toUpperCase()))									s += " UNKNOWN ABCConsts.OPreader.swfutils::_dataInput"*/								break						}												//var size:int = opReader.position - start;				//					totalSize += size						//ABCConsts.opSizes[opcode] = int(ABCConsts.opSizes[opcode]) + size;						print( s );					}				}			}							unindent();			print('</MethodCode>');								}	}}dynamic internal class ABCLabelInfo{	public var count:int;		public function labelFor (target:int):String	{		if (target in this)			return this[target];					return this[target] = "L" + (++count);	}}