/* * The Spark Project ( http://libspark.org ) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. * * The Original Code is [Open Source Virtual Machine.]. * * The Initial Developer of the Original Code is Adobe System Incorporated. * Portions created by the Initial Developer are Copyright (C) 2004-2006 * the Initial Developer. All Rights Reserved. * * Contributor(s): * * Adobe AS3 Team * Mateusz Malczak ( http://segfaultlabs.com ) * Daniel Riley	 ( http://scientificsciences.com ) */package org.libspark.swfassist.swf.abc.io{	import flash.utils.getQualifiedClassName;		import org.libspark.swfassist.errors.ErrorHandler;	import org.libspark.swfassist.errors.ErrorIdConstants;	import org.libspark.swfassist.errors.ErrorMessageConstants;	import org.libspark.swfassist.errors.Warning;	import org.libspark.swfassist.utils.BitwiseUtil;		import org.libspark.swfassist.swf.abc.consts.ABCConsts;		import org.libspark.swfassist.swf.abc.structures.ABCClass;		import org.libspark.swfassist.swf.abc.structures.ABCCPool;	import org.libspark.swfassist.swf.abc.structures.ABCExceptionInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInstance;	import org.libspark.swfassist.swf.abc.structures.ABCMethodBody;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfoOptional;	import org.libspark.swfassist.swf.abc.structures.ABCMetaData;	import org.libspark.swfassist.swf.abc.structures.ABCMultiname;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameQName;	import org.libspark.swfassist.swf.abc.structures.IABCMultinameData;	import org.libspark.swfassist.swf.abc.structures.ABCNamespace;	import org.libspark.swfassist.swf.abc.structures.ABCNamespaceSet;	import org.libspark.swfassist.swf.abc.structures.ABCTraits;	import org.libspark.swfassist.swf.abc.structures.ABCTraitsInfo;	import org.libspark.swfassist.swf.abc.structures.ABCTraitConstSlot;	import org.libspark.swfassist.swf.abc.structures.ABCTypeName;	import org.libspark.swfassist.swf.abc.structures.IABCTraits;			import org.libspark.swfassist.io.ByteArrayInputStream;	import flash.utils.ByteArray;	import flash.utils.Endian;		import flash.utils.getTimer;		/**	 * Code in this class is heavily based om code from Tamarin project. 	 * ABCReader class is used to parse a single doABC tag from a SWF file. On exit we get obejcts representing	 *  	 * @author malczak	 * @author danriley	 * @version 0.3	 */		public final class ABCReader	{		private function error( context:ABCReadingContext, id:uint, message:String = ''):void		{			var e:Error = new Error(message, id);			var handler:ErrorHandler = context.errorHandler;						if (!handler || !handler.handleError(e)) {				throw e;			}		}						/**		 * Method for parsing an ABC code block into an ABCInfo instance.		 * All constants used in the block are stored in an ABCCPool 		 * object. The constant pool is common for all doABC blocks in 		 * the file, so the cpool property of the ABCInfo instance should		 * be a reference to the global cpool object, however, the code		 * currently reads a separate cpool object for each doABC block,		 * this may need to be fixed in the future, although I have not		 * yet encountered a file with multiple doABC blocks.		 *		 * @param input - swf file reading stream		 * @param context - Object holds flags pertaining to how the file should be read, 		 *					and also stores the current position so the file can be read 		 *					in a thread-style loop.		 * @param abcInfo - ABCinfo instance that will store all data from parsed doABC block		 * @param maxTime - The maximum time in milliseconds that the file should be read for.		 * 		 */				public function readABC( input:ByteArrayInputStream, context:ABCReadingContext, abcInfo:ABCInfo = null, maxTime:int = 0 ):ABCInfo		{			if( abcInfo == null ) {				abcInfo = new ABCInfo();			}						if( maxTime == 0 ) {				maxTime = uint.MAX_VALUE;			}							var startTime:uint = getTimer();			var complete:Boolean = context.cursor == ABCContext.CURSOR_COMPLETE;						while( !complete )			{				if( input.bytesAvailable > 0 ) 				{					switch( context.cursor )					{						case ABCContext.CURSOR_HEADER:							readHeader( input, abcInfo, context );							break;														case ABCContext.CURSOR_CPOOL:							readCPool( input, abcInfo, context );							break;													case ABCContext.CURSOR_METHODS:							readMethods( input, abcInfo, context );							break;													case ABCContext.CURSOR_METADATA:							readMetaData( input, abcInfo, context );							break;												case ABCContext.CURSOR_INSTANCES:							readInstances( input, abcInfo, context );							break;													case ABCContext.CURSOR_CLASSES:							readClasses( input, abcInfo, context );							break;													case ABCContext.CURSOR_SCRIPTS:							readScripts( input, abcInfo, context );							break;													case ABCContext.CURSOR_METHODBODIES:							readMethodBodies( input, abcInfo, context );							break;												}										// Read the next section of data or quit					context.updateCursor();										if( getTimer() - startTime > maxTime || context.cursor == ABCContext.CURSOR_COMPLETE ) {						complete = true;					}										} else {					error( context, ErrorIdConstants.INVALID_FILE_LENGTH, ErrorMessageConstants.INVALID_FILE_LENGTH);				}			}							return abcInfo;		}						/**		 * Reads the header of the data stream, contains version information		 * see SWF File Format Spec and/or AVM spec.		 *		 * @param input - swf file reading stream		 * @param abcInfo - ABCinfo that will store all data from parsed doABC block		 * @param context - The reading context		 * 		 */			public function readHeader( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			abcInfo.target = input.readString();			abcInfo.minor = input.readS16();			abcInfo.major = input.readS16();						if ( abcInfo.minor!=16 && abcInfo.major!=46  )				error( context, ErrorIdConstants.INVALID_ABCINFO, ErrorMessageConstants.INVALID_ABCINFO);		}				/**		 * Reads the constant pool data from the code block. Contains stored Numbers		 * Namespaces, Namespace Sets, and Multinames referenced by the Op Codes		 * in a method body. See SWF File Format Spec and/or AVM spec.		 *		 * @param input - swf file reading stream		 * @param abcInfo - ABCinfo that will store all data from parsed doABC block		 * @param context - The reading context.		 * 		 */			public function readCPool( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();						var i:int;			var n:int;						if( abcInfo.cpool == null )				abcInfo.cpool = new ABCCPool();							var cpool:ABCCPool = abcInfo.cpool;						// Read Numbers			var start:int = input.position;			// Ints			i = cpool.initInts()-1;			n = i + input.readEncodedU32();						while ( ++i < n )				cpool.ints[i] = input.readEncodedS32();									// Uints			i = cpool.initUInts()-1;			n = i + input.readEncodedU32();						while ( ++i < n )				cpool.uints[i] = input.readEncodedS32();											// Doubles			i = cpool.initDoubles()-1;			n = i + input.readEncodedU32();						while ( ++i < n )				cpool.doubles[i] = input.readDouble();			trace("ABCReader: Read " + cpool.numInts + " Ints, " + cpool.numUInts + " UInts, " + cpool.numDoubles + " Doubles in " + (input.position-start) + " bytes.")			// Read Strings			start = input.position;						i = cpool.initStrings()-1;			n = i + input.readEncodedU32();			var length:uint;						while ( ++i < n )			{				length = input.readEncodedU32();				cpool.strings[i] = !length ? "" : input.readUTF( length );			}			trace("ABCReader: Read "+ cpool.numStrings + " Strings in " + (input.position-start) + " bytes.")									// Read Namespaces			start = input.position;			var stringIndex:int;			var constantType:int;						i = cpool.initNamespaces()-1;			n = i + input.readEncodedU32();						while ( ++i < n )			{				constantType = input.readS8();				stringIndex = input.readEncodedU32();								switch ( constantType )				{					case ABCConsts.CONSTANT_Namespace: // user ns */					case ABCConsts.CONSTANT_ExplicitNamespace:												case ABCConsts.CONSTANT_PackageNs:// package public ns */					case ABCConsts.CONSTANT_PackageInternalNs:// internal ns */								cpool.namespaces[i] = new ABCNamespace( constantType, cpool.getString(stringIndex) );								break;													case ABCConsts.CONSTANT_ProtectedNs:					case ABCConsts.CONSTANT_StaticProtectedNs:					case ABCConsts.CONSTANT_PrivateNs:								cpool.namespaces[i] = new ABCNamespace( constantType );								break;				}			}			trace("ABCReader: Read " + cpool.numNamespaces + " Namespaces in " + (input.position-start) + " bytes.");									// Read Namespace Sets			start = input.position;			var setLength:int;			var j:int;			var nsset:Array;			i = cpool.initNSSets()-1;			n = i + input.readEncodedU32();						while ( ++i < n )			{				setLength = input.readEncodedU32();								nsset = new Array(setLength);								j = -1;				while( ++j < setLength )					nsset[j] = cpool.getNamespace(input.readEncodedU32());									cpool.nssets[i] = new ABCNamespaceSet( nsset );			}			trace("ABCReader: Read "+ cpool.numNSSets +" Namespace Sets in " + (input.position-start) + " bytes.");									// Read Multinames			start = input.position;			var mni:ABCMultinameInfo;			var mnid:IABCMultinameData;						i = cpool.initMultinames()-1;			n = i + input.readEncodedU32();						while ( ++i < n )			{				constantType = input.readS8()								switch ( constantType ) 				{					case ABCConsts.CONSTANT_Qname:					case ABCConsts.CONSTANT_QnameA:							mnid = new ABCMultinameQName( cpool.getNamespace(input.readEncodedU32()), cpool.getString(input.readEncodedU32()) );						break;										case ABCConsts.CONSTANT_RTQname:					case ABCConsts.CONSTANT_RTQnameA:							mnid = new ABCMultinameQName( cpool.getNamespace(input.readEncodedU32()) );						break;										case ABCConsts.CONSTANT_RTQnameL:					case ABCConsts.CONSTANT_RTQnameLA:							mnid = null;						break;										// these don't appear in the documentation					case ABCConsts.CONSTANT_NameL:					case ABCConsts.CONSTANT_NameLA:							trace("constant");							//mnid = new ABCMultinameQName( new Namespace(""), null );						break;					case ABCConsts.CONSTANT_Multiname:					case ABCConsts.CONSTANT_MultinameA:							mnid = new ABCMultiname( cpool.getString(input.readEncodedU32()), cpool.getNSSet(input.readEncodedU32())) ;						break;						case ABCConsts.CONSTANT_MultinameL:					case ABCConsts.CONSTANT_MultinameLA:							mnid = new ABCMultiname( null, cpool.getNSSet(input.readEncodedU32()));						break;											case ABCConsts.CONSTANT_TypeName: 							/* TypeName, used since fp10. not documented, based on abcdump.as */							var types:Array = new Array();							j = input.readEncodedU32();							for ( ;j>0;j-=1)								types.push( cpool.getMultiname(input.readEncodedU32()) );															mnid = new ABCTypeName( cpool.getString(input.readEncodedU32()), types );						break;											default:						error( context, ErrorIdConstants.INVALID_MULTINAME, ErrorMessageConstants.INVALID_MULTINAME);						break;				}								if( mnid != null )				{					var mn:ABCMultinameInfo = new ABCMultinameInfo( constantType, mnid );					cpool.names[i] = mn;				} else {					error( context, ErrorIdConstants.INVALID_MULTINAME, ErrorMessageConstants.INVALID_MULTINAME);				}			}						trace("ABCReader: Read " + cpool.numMultinames +" Multinames in " + (input.position-start) + " bytes.");			// Method timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read Constant Pool in " + methodTime.toFixed(3) + " seconds.")		}				/**		 * Method to read the method info into the abcInfo method array.		 */		public function readMethods( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();			var method:ABCMethodInfo;			var cpool:ABCCPool = abcInfo.cpool;						// Initialize			if( abcInfo.methods == null ) {				abcInfo.methods = new Vector.<ABCMethodInfo>();			}						var methodCount:uint = abcInfo.methods.length;						var start:int = input.position;			var n:uint = input.readEncodedU32();			var i:int = -1;						while( ++i < n )			{				method = new ABCMethodInfo();				abcInfo.methods[methodCount++] = method;				var paramCount:uint = input.readEncodedU32();								method.returnType = cpool.getMultiname(input.readEncodedU32());				method.paramTypes = new Vector.<ABCMultinameInfo>( paramCount );								var j:int = -1;				while( ++j < paramCount ) {					method.paramTypes[j] = cpool.getMultiname(input.readEncodedU32());				}				method.debugName = cpool.getString(input.readEncodedU32()); /* this is just a debug name */				method.flags = input.readS8();								var k:int = 0;				if (method.flags & ABCConsts.HAS_OPTIONAL) 				{					var optionalCount:uint = input.readEncodedU32();										method.optionalValues = [];										k = paramCount - optionalCount - 1;					while( ++k < paramCount) 					{						var index:uint = input.readEncodedU32()    // optional value index						var kind:int = input.readS8() // kind byte for each default value						if (index == 0)							method.optionalValues[k] = undefined;						else 							method.optionalValues[k] = new ABCMethodInfoOptional( kind, index, defaultValue( kind, index, cpool ));					}				}								if (method.flags & ABCConsts.HAS_ParamNames) 				{					method.paramNames = new Vector.<String>( paramCount );										k = -1;					while( ++k < paramCount )												method.paramNames[k] = cpool.getString(input.readEncodedU32());                }							}					// Method Timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + n + " Methods in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.");		}				/**		 * Method to read the metadata into the abcInfo metadata array.		 */		public function readMetaData( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();			// Initialize			if( abcInfo.metadata == null ) {				abcInfo.metadata = new Vector.<ABCMetaData>();			}						var metadataCount:uint = abcInfo.metadata.length;						var i:int;			var md:ABCMetaData;			var cpool:ABCCPool = abcInfo.cpool;						var start:int = input.position;			var n:uint = input.readEncodedU32();						var metaname:Vector.<String>;						var j:int = -1;			while ( ++j < n ) 			{				// MetadataInfo				md = new ABCMetaData();								abcInfo.metadata[metadataCount++] = md;								md.name = cpool.getString(input.readEncodedU32());					            var valuesCount:uint = input.readEncodedU32();				metaname = new Vector.<String>( valuesCount );					            for( i = 0; i < valuesCount; ++i )					metaname[i] = cpool.getString(input.readEncodedU32()); // name 									for( i = 0; i < valuesCount; ++i )					md[metaname[i]] = cpool.getString(input.readEncodedU32()); // value			}					// Method Timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + n + " Metadata in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.")		}				/**		 * Method to read an instance into the abcInfo instance array.		 */		public function readInstances( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();			var cpool		:ABCCPool = abcInfo.cpool;			var instance	:ABCInstance;						var instanceCount:uint = abcInfo.instances.length;						var start:int = input.position;			var n:uint = input.readEncodedU32();			var i:int = -1;			while ( ++i < n ) 			{	        	abcInfo.instances[instanceCount++] = instance = new ABCInstance();					        	instance.name = cpool.getMultiname(input.readEncodedU32());	        	instance.base = cpool.getMultiname(input.readEncodedU32());					        	instance.flags = input.readS8();								if (instance.flags & 8)					instance.protectedNs = cpool.getNamespace(input.readEncodedU32());	        	var interfaceCount:int = input.readEncodedU32();								var j:int = -1;				while( ++j < interfaceCount )					instance.interfaces[j] = cpool.getMultiname(input.readEncodedU32());								/* instance initializer */				instance.init = abcInfo.getMethod(input.readEncodedU32());				/* set of traits for instance */	        	readTraits( input, abcInfo, instance );	        }	        			// Method Timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + n + " Instances in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.")		}				public function readClasses( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();						var clss:ABCClass;			var classCount:uint = abcInfo.classes.length;						var n:uint = abcInfo.instances.length;			var start:int = input.position;						var i:int = -1;			while( ++i < n )			{	        	abcInfo.classes[classCount++] = clss = new ABCClass();				clss.instanceRef = abcInfo.getInstance(i); // ith class_info i always connected with ith instance_info	        	clss.init = abcInfo.getMethod(input.readEncodedU32()); // static class initializer 				clss.kind = ABCConsts.TRAIT_Class; // class name	        	readTraits( input, abcInfo, clss ); //class traits ~ static properties & methods			}								// Method Timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + n + " Classes in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.")		}					public function readScripts( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();			var scriptCount:uint = abcInfo.scripts.length;						var start:int = input.position;			var n:uint = input.readEncodedU32();			var script:ABCTraits;			var i:int = -1;			while( ++i < n )			{					        	abcInfo.scripts[scriptCount++] = script = new ABCTraits();	        	script.init = abcInfo.getMethod(input.readEncodedU32());	        	readTraits( input, abcInfo, script); // traits for script, public class definition and all internal data								var traitCount:uint = script.traits.length;				while( --traitCount > -1 )				{					var clss:ABCClass = script.traits[traitCount] as ABCClass;					if( clss )					{						clss.scriptRef = script;					}				}		        }			//Method Timing			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + n + " Scripts in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.")		}				public function readMethodBodies( input:ByteArrayInputStream, abcInfo:ABCInfo, context:ABCReadingContext )		{			var methodTime:Number = getTimer();			var n:int;						var k:int;									var method	:ABCMethodInfo;			var ex		:ABCExceptionInfo;						var cpool	:ABCCPool = abcInfo.cpool;						var bytes	:ByteArray = new ByteArray();			var body	:ABCMethodBody;			/* annonimous functions has kind set to 0, which means function is a variable of type Function.			 * code is assigned in runtime. this way package funcitons are dealed. 			 **/			 			var start:int = input.position;						// Initialize, or continue reading based on context, if its the			// first read, then grab the number of methods			if (context.methodBodyLimit == 0) {				context.methodBodyLimit = uint.MAX_VALUE;			}						if( context.methodBodyCount == -1 ) {				context.methodBodyCount = input.readEncodedU32();			}						var i:int = -1;			while( ++i < context.methodBodyLimit && (i + context.methodBodyCursor) < context.methodBodyCount )			{				method = abcInfo.getMethod(input.readEncodedU32());				method.body = body = new ABCMethodBody();				method.annonimous = false;								body.init = method;				body.maxStack = input.readEncodedU32();	        	body.localCount = input.readEncodedU32();				body.initScope =  input.readEncodedU32();				body.maxScope =  input.readEncodedU32();				bytes.endian = Endian.LITTLE_ENDIAN;				input.readBytes( bytes, input.readEncodedU32() );								if ( context.readMethodBytes ) {					body.code = bytes;					bytes = new ByteArray();				} else 					bytes.length = 0;						       		var exceptionCount:uint = body.exceptions.length;				if ( (k = input.readEncodedU32()) > 0 )				{					ex = new ABCExceptionInfo();										var j:int = -1;					while( ++j < k )					{						ex.from = input.readEncodedU32()						ex.to = input.readEncodedU32()						ex.target = input.readEncodedU32()						ex.ectType = cpool.getString(input.readEncodedU32());						ex.varName = cpool.getString(input.readEncodedU32());												if ( context.readExceptions ) 						{							body.exceptions[exceptionCount++] = ex;							ex = new ABCExceptionInfo();						}					}				}								readTraits( input, abcInfo, body );	        }						context.methodBodyCursor += i;						bytes.length = 0;			bytes = null;	    			methodTime = (getTimer() - methodTime)/1000;			trace("ABCReader: Read " + i + " MethodBodies in "+(input.position-start)+" bytes in " + methodTime.toFixed(3) + " seconds.")		}		/**		 * Method is used to read all traits_info entries for specified object.		 * Traits are defined for classes (static methods, static slots/consts), 		 * for scripts (script public/private classes, script methods, script variables)		 * and for instances (slots, consts, methods). 		 * 		 * For more information refere to : "ActionScript Virtual Machine 2 (AVM2) Overview"		 * A trait is a fixed-name property shared by all objects that are instances of 		 * the same class; a set of traits expresses the type of an object.		 *  		 * 		 * @param t - objects for which traits should be read  		 * @param abc - ABCinfo object		 * 		 */			private function readTraits( input:ByteArrayInputStream, abcInfo:ABCInfo, t:IABCTraits ):void		{			var trait		:*; // could be any kind of trait			var cpool		:ABCCPool = abcInfo.cpool;			var classes		:Vector.<ABCClass> = abcInfo.classes;			var metadata	:Vector.<ABCMetaData> = abcInfo.metadata;									var dummy		:uint;			var name		:ABCMultinameInfo;			var kind		:uint;			var id			:uint;			var traits		:Array = t.traits;			var i:int = -1;			var j:int;						var nameCount	:int = input.readEncodedU32();						while( ++i < nameCount )			{				/* trait name ~ property name */				name = cpool.getMultiname(input.readEncodedU32());								/* trait kind */				kind = input.readS8();								/* meaning depends on trait kind */				id = input.readEncodedU32(); 				switch( kind & 0x0f ) 				{					/* primitive var & const properties */					case ABCConsts.TRAIT_Slot:					case ABCConsts.TRAIT_Const:							var cs:ABCTraitConstSlot = new ABCTraitConstSlot();							cs.type = cpool.getMultiname(input.readEncodedU32());							cs.vindex = input.readEncodedU32();							if ( cs.vindex )  {								cs.vkind = input.readS8();								cs.value = defaultValue( cs.vkind, cs.vindex, cpool );							}							trait = cs;						break;					/* class property this is only present for scripts ? */					case ABCConsts.TRAIT_Class:							trait = abcInfo.getClass(input.readEncodedU32());						break;					/* methods */					case ABCConsts.TRAIT_Function:					case ABCConsts.TRAIT_Method:					case ABCConsts.TRAIT_Getter:					case ABCConsts.TRAIT_Setter:							trait = abcInfo.getMethod(input.readEncodedU32());						break;										}								trait.name = name;				trait.kind = kind;				trait.id = id;														if ( (trait.kind >> 4) & ABCConsts.ATTR_metadata ) {					trait.metadata = [];					var metadata_count:int = input.readEncodedU32();										for( j=0; j < metadata_count; ++j)						trait.metadata.push(  metadata[ input.readEncodedU32() ] );				};								traits.push( trait );			}		}				/**		 * For information refer to : "ActionScript Virtual Machine 2 (AVM2) Overview"		 */		protected function defaultValue( kind : uint, idx : uint, cpool : ABCCPool ):*		{			switch ( kind )			{				case ABCConsts.CONSTANT_Utf8:   return cpool.getString(idx);				case ABCConsts.CONSTANT_UInt:				case ABCConsts.CONSTANT_Int:    return cpool.getInt(idx);				case ABCConsts.CONSTANT_UInt:   return cpool.getUInt(idx);				case ABCConsts.CONSTANT_Double: return cpool.getDouble(idx);												case ABCConsts.CONSTANT_Namespace:				case ABCConsts.CONSTANT_PrivateNs:				case ABCConsts.CONSTANT_PackageNs:				case ABCConsts.CONSTANT_PackageInternalNs:				case ABCConsts.CONSTANT_ProtectedNs:				case ABCConsts.CONSTANT_ExplicitNamespace:				case ABCConsts.CONSTANT_StaticProtectedNs: 												return cpool.getNamespace(idx);								case ABCConsts.CONSTANT_False:  return false;// { 10:false }				case ABCConsts.CONSTANT_True:   return true;// { 11:true }				case ABCConsts.CONSTANT_Null:   return null;//{ 12: null }			};				}; 	};}