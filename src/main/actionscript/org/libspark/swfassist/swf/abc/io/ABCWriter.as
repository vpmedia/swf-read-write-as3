/* * The Spark Project ( http://libspark.org ) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. * * The Original Code is [Open Source Virtual Machine.]. * * The Initial Developer of the Original Code is Adobe System Incorporated. * Portions created by the Initial Developer are Copyright (C) 2004-2006 * the Initial Developer. All Rights Reserved. * * Contributor(s): * * Adobe AS3 Team * Mateusz Malczak ( http://segfaultlabs.com ) * Daniel Riley	 ( http://scientificsciences.com ) */package org.libspark.swfassist.swf.abc.io{	import org.libspark.swfassist.errors.ErrorHandler;	import org.libspark.swfassist.errors.ErrorIdConstants;	import org.libspark.swfassist.errors.ErrorMessageConstants;	import org.libspark.swfassist.errors.Warning;			import org.libspark.swfassist.swf.abc.consts.ABCConsts;		import org.libspark.swfassist.swf.abc.structures.ABCClass;	import org.libspark.swfassist.swf.abc.structures.ABCCPool;	import org.libspark.swfassist.swf.abc.structures.ABCExceptionInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInstance;	import org.libspark.swfassist.swf.abc.structures.ABCMethodBody;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfoOptional;	import org.libspark.swfassist.swf.abc.structures.ABCMetaData;	import org.libspark.swfassist.swf.abc.structures.ABCMultiname;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameQName;	import org.libspark.swfassist.swf.abc.structures.IABCMultinameData;	import org.libspark.swfassist.swf.abc.structures.ABCNamespace;	import org.libspark.swfassist.swf.abc.structures.ABCTraits;	import org.libspark.swfassist.swf.abc.structures.ABCTraitsInfo;	import org.libspark.swfassist.swf.abc.structures.ABCTraitConstSlot;	import org.libspark.swfassist.swf.abc.structures.ABCTypeName;	import org.libspark.swfassist.swf.abc.structures.IABCTraits;		import org.libspark.swfassist.io.ByteArrayInputStream;	import org.libspark.swfassist.io.ByteArrayOutputStream;	import flash.utils.ByteArray;	import flash.utils.Endian;		import flash.utils.getTimer;		/**	 * The comlement to ABCReader. Writes out abcInfo to byteCode	 *  	 * @author danriley	 * @version 0.1	 */		public final class ABCWriter	{				private var _abcData:ByteArrayOutputStream = new ByteArrayOutputStream(new ByteArray());				public function ABCWriter()		{ 		}				private function error( id:uint, message:String = ''):void		{			var e:Error = new Error(message, id);			//var handler:ErrorHandler = context.errorHandler;						//if (!handler || !handler.handleError(e)) {				throw e;			//}		}				/*public function writeABC( output:ByteArrayOutputStream, abcInfo:ABCInfo ):void		{							writeHeader( output, abcInfo );			writeCPool( output, abcInfo );			writeMethods( output, abcInfo );			writeMetaData( output, abcInfo );			writeInstances( output, abcInfo );			writeClasses( output, abcInfo );			writeScripts( output, abcInfo );			writeMethodBodies( output, abcInfo );		}*/				public function writeABC( output:ByteArrayOutputStream, abcContext:ABCWritingContext, abcInfo:ABCInfo = null, maxTime:uint = 0 ):void		{			if( abcInfo == null ) {				abcInfo = new ABCInfo();			}						if( maxTime == 0 ) {				maxTime = uint.MAX_VALUE;			}							var startTime:uint = getTimer();			var complete:Boolean = abcContext.cursor == ABCContext.CURSOR_COMPLETE;			while( !complete )			{				switch( abcContext.cursor )				{					case ABCContext.CURSOR_HEADER:						writeHeader( output, abcInfo, abcContext );						break;												case ABCContext.CURSOR_CPOOL:						writeCPool( output, abcInfo, abcContext );						break;											case ABCContext.CURSOR_METHODS:						writeMethods( output, abcInfo, abcContext );						break;											case ABCContext.CURSOR_METADATA:						writeMetaData( output, abcInfo, abcContext );						break;										case ABCContext.CURSOR_INSTANCES:						writeInstances( output, abcInfo, abcContext );						break;											case ABCContext.CURSOR_CLASSES:						writeClasses( output, abcInfo, abcContext );						break;											case ABCContext.CURSOR_SCRIPTS:						writeScripts( output, abcInfo, abcContext );						break;											case ABCContext.CURSOR_METHODBODIES:						writeMethodBodies( output, abcInfo, abcContext );						break;										}								// Read the next section of data or quit				abcContext.updateCursor();								if( getTimer() - startTime > maxTime || abcContext.cursor == ABCContext.CURSOR_COMPLETE ) {					complete = true;				}									}		}				private function writeHeader( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			output.writeString( abcInfo.target );			output.writeS16( abcInfo.minor );			output.writeS16( abcInfo.major );		}				private function writeCPool( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			var i:int;			var n:int;			var cpool:ABCCPool = abcInfo.cpool;			var start:uint = output.position;						// ints			n = cpool.numInts;			output.writeEncodedU32( n );			for (i=1; i < n; i++)				output.writeEncodedS32( cpool.ints[i] );							// uints			n = cpool.numUInts;			output.writeEncodedU32( n );			for (i=1; i < n; i++)				output.writeEncodedU32( cpool.uints[i] );							// doubles			n = cpool.numDoubles;			output.writeEncodedU32( n );						for (i=1; i < n; i++) 				output.writeDouble( cpool.doubles[i] );											// strings			start = output.position;							n = cpool.numStrings;			output.writeEncodedU32( n );			for (i = 1; i < n; i++) 			{				if( cpool.strings[i].length > 0 ) 				{					output.writeUTFBytes( cpool.strings[i] );				} 				else 				{					output.writeEncodedU32( 0 );				}			}						trace("ABCWriter: Wrote Strings in " + (output.position - start) + " bytes.");			// namespaces			start = output.position;			n = cpool.numNamespaces;			var j:int;			var k:int;						output.writeEncodedU32( n );						for (i = 1; i < n; i++) {								//write the kind				output.writeS8( cpool.namespaces[i].kind );								//get the name				if( cpool.namespaces[i].name == cpool.namespaces[0].name )					output.writeEncodedU32( 0 );				else {										output.writeEncodedU32( cpool.getStringIndex( cpool.namespaces[i].name ) );				}											}						trace("namespace size = " + (output.position - start));									// namespace sets			start = output.position;			var nsidx:int = -1;			var nameidx:int = -1;			n = cpool.numNSSets;			output.writeEncodedU32( n );			for (i=1; i < n; i++) {								// the length of this namespace set				output.writeEncodedU32( cpool.nssets[i].length );								for( j = 0; j < cpool.nssets[i].length; j++ ) {										output.writeEncodedU32( cpool.getNamespaceIndex( cpool.nssets[i].getNamespace(j) ) );					/*nsidx = cpool.namespaces.indexOf( cpool.nssets[i][j] );					if( nsidx != -1 )						output.writeEncodedU32( nsidx );					else{												error( ErrorIdConstants.INVALID_NAMESPACE, ErrorMessageConstants.INVALID_NAMESPACE);					}*/									}			}						trace("namespaceset size = " + (output.position - start));			// mulitnames			n = cpool.numMultinames;			output.writeEncodedU32( n );										for (i=1; i < n; i++) 			{								output.writeS8( cpool.names[i].kind );				switch ( cpool.names[i].kind ) {					case ABCConsts.CONSTANT_Qname:					case ABCConsts.CONSTANT_QnameA:							var qData:ABCMultinameQName = cpool.names[i].data as ABCMultinameQName;														output.writeEncodedU32( cpool.getNamespaceIndex( qData.ns ) );							output.writeEncodedU32( cpool.getStringIndex( qData.n ) );						break;										case ABCConsts.CONSTANT_RTQname:					case ABCConsts.CONSTANT_RTQnameA:							var rtqData:ABCMultinameQName = cpool.names[i].data as ABCMultinameQName;														output.writeEncodedU32( cpool.getStringIndex( rtqData.n ) );						break;										case ABCConsts.CONSTANT_RTQnameL:					case ABCConsts.CONSTANT_RTQnameLA:							// no data						break;										// these don't appear in the documentation					/*					case ABCConsts.CONSTANT_NameL:					case ABCConsts.CONSTANT_NameLA:							mnid = new ABCMultinameQName( new Namespace(""), null );						break;						*/															case ABCConsts.CONSTANT_Multiname:					case ABCConsts.CONSTANT_MultinameA:							var mData:ABCMultiname = ABCMultiname(cpool.getMultiname(i).data);												output.writeEncodedU32( cpool.getStringIndex( mData.name ) );							output.writeEncodedU32( cpool.getNSSetIndex( mData.nsset ) );						break;						case ABCConsts.CONSTANT_MultinameL:					case ABCConsts.CONSTANT_MultinameLA:							var mData:ABCMultiname = ABCMultiname(cpool.getMultiname(i).data);							output.writeEncodedU32( cpool.getNSSetIndex( mData.nsset ) );						break;											case ABCConsts.CONSTANT_TypeName: 							/* TypeName, used since fp10. not documented, based on abcdump.as */							var tData:ABCTypeName = cpool.names[i].data as ABCTypeName;														output.writeEncodedU32( tData.types.length );							for (var j:int = 0 ;j<tData.types.length;j++) 								output.writeEncodedU32( cpool.getMultinameIndex( tData.types[j] ) );								break;											default:						error( ErrorIdConstants.INVALID_MULTINAME, ErrorMessageConstants.INVALID_MULTINAME);				}							}		}						private function writeMethods( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{								var i:int;			var j:int;			var k:int;			var cpool:ABCCPool = abcInfo.cpool;			var methods:Vector.<ABCMethodInfo> = abcInfo.methods;			var m:ABCMethodInfo;			var start:int = output.position;						if( abcContext.methodCount == -1 )			{								abcContext.methodCount = methods.length;				output.writeEncodedU32( abcContext.methodCount );			}						var mstart:int;			for ( i = 0; i < methods.length; i++ ) {				mstart = output.position;				m = methods[i];								var numParams:int = m.paramTypes.length;								output.writeEncodedU32( numParams );								output.writeEncodedU32( cpool.getMultinameIndex( m.returnType ) );								for ( j = 0; j < numParams; j++)					output.writeEncodedU32( cpool.getMultinameIndex( m.paramTypes[j] ) ); //return type									output.writeEncodedU32(cpool.getStringIndex( m.debugName )); //debugname								output.writeS8( m.flags );				if ((m.flags & ABCConsts.HAS_OPTIONAL) && m.optionalValues != null) {																				k = -1;					while( m.optionalValues[++k] == null ){						// find first optional value					}										var numOptional:int = m.optionalValues.length-k;//m.optionalValues.length;										// has_optional					output.writeEncodedU32( numOptional ); // param count															for( k = numParams-numOptional; k < numParams; k++ ) {						var optional:ABCMethodInfoOptional = m.optionalValues[k];						output.writeEncodedU32( optional.value );						output.writeS8( optional.kind );					}				}								//Param names				if ((m.flags & ABCConsts.HAS_ParamNames) && m.paramNames.length > 0) {										for( k = 0; k < numParams; ++k)								output.writeEncodedU32( cpool.getStringIndex( m.paramNames[k] ) );						                }								//trace("method: " + i + " length: " + (output.position - mstart) +", params: " +numParams+", f: " + m.flags);			}					trace("ABCMethodInfo count  size "+(output.position-start))			abcInfo.methods = methods;		}			private function writeMetaData( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			// Initialize local vars			var i:int;			var n:int;			var md:ABCMetaData;			var start:int;						// Get ABCInfo vars			var cpool:ABCCPool = abcInfo.cpool;			var metadata:Vector.<ABCMetaData> = abcInfo.metadata;						start = output.position;			n = metadata.length;						trace("writing metadata size at " + output.position);			output.writeEncodedU32( n );						for ( i = 0; i < n; i++ ) {				// MetadataInfo				md = metadata[i];								output.writeEncodedU32( cpool.getStringIndex( md.name ) );				var metaname:Array = new Array();								// grab all properties from metadata object, that				// has a String value and aren't normal variables				for( var nm:String in md )					if( nm != "name" && md[nm] is String )						metaname.push( {name:nm, val:md[nm]} );													            output.writeEncodedU32( metaname.length );	            for( i = 0; i < metaname.length; ++i )					output.writeEncodedU32( cpool.getStringIndex( metaname[i].name ) ); // name 				for( i = 0; i < metaname.length; ++i )					output.writeEncodedU32( cpool.getStringIndex( metaname[i].val ) ); // value 			}					trace("MetadataInfo " + n + " count : size "+(output.position-start));		}				private function writeInstances( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			// Initialize local			var i:int;			var n:int;			var j:int;			var t:ABCInstance;			var start:int;									// Get ABCInfo vars			var cpool		:ABCCPool = abcInfo.cpool;			var instances	:Vector.<ABCInstance> = abcInfo.instances;						start = output.position;						n = instances.length;						output.writeEncodedU32( n );			for ( i = 0; i < n; i++ ) {	        					t = instances[i];								output.writeEncodedU32( cpool.getMultinameIndex( t.name ) );				output.writeEncodedU32( cpool.getMultinameIndex( t.base ) );				output.writeS8( t.flags );				if (t.flags & 8) {					output.writeEncodedU32( cpool.getNamespaceIndex( t.protectedNs ) );				}									// interfaces 				var interface_count:int = t.interfaces != null ? t.interfaces.length : 0;								output.writeEncodedU32( interface_count );	        					for ( j = 0; j < interface_count; j++)					output.writeEncodedU32( cpool.getMultinameIndex( t.interfaces[j] ) );								// instance initializer 				output.writeEncodedU32( abcInfo.getMethodIndex( t.init ) );								// set of traits for instance 	        	writeTraits( output, abcInfo, t );	        }	        			trace("InstanceInfo size "+(output.position-start));		}				private function writeClasses( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			var i:int;			var n:int;			var ct:ABCClass;			var start:int = output.position;			var instances:Vector.<ABCInstance> = abcInfo.instances;			var classes:Vector.<ABCClass> = abcInfo.classes;						n = classes.length;						if( classes.length != instances.length )				error( ErrorIdConstants.INVALID_NUM_CLASSES, ErrorMessageConstants.INVALID_NUM_CLASSES);						for ( i=0; i < n; i++ ) {								ct = classes[i];								// static class initializer 	        	output.writeEncodedU32( abcInfo.getMethodIndex( ct.init ) );								// class traits ~ static properties & methods 	        	writeTraits( output, abcInfo, ct );			}								trace("ClassInfo size "+( output.position-start));					}					private function writeScripts( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			var n:int;			var i:int;			var start:int = output.position;			var st:ABCTraits;			var ct:ABCClass;						var scripts:Vector.<ABCTraits> = abcInfo.scripts;						// single as3 script, here only one public class 			output.writeEncodedU32( scripts.length );						for ( i = 0; i < scripts.length; i++ ) {					        	st = scripts[i];								// AS3 initial script 				output.writeEncodedU32( abcInfo.getMethodIndex( st.init ) );								// traits for script, public class definition and all internal data 	        	writeTraits( output, abcInfo, st);					        							        }			trace("ScriptInfo size : "+(output.position-start))		}				private function writeMethodBodies( output:ByteArrayOutputStream, abcInfo:ABCInfo, abcContext:ABCWritingContext )		{			var n:int;			var i:int;			var k:int;			var j:int;			var start:int = output.position;			var method	:ABCMethodInfo;			var ex		:ABCExceptionInfo;						// Initialize, or continue reading based on context. If its the			// first write, then grab the number of methods and store them.			if (abcContext.methodBodyLimit == 0) {				abcContext.methodBodyLimit = uint.MAX_VALUE;			}						if( abcContext.methodBodyCount == -1 ) 			{				abcContext.methodBodyCount = 0;								// Go through and count all of the method bodies				for( i=0; i<abcContext.methodCount; i++ )					if( abcInfo.methods[i].body != null && abcInfo.methods[i].body is ABCMethodBody )						abcContext.methodBodyCount++;										output.writeEncodedU32( abcContext.methodBodyCount );			}						i = abcContext.methodBodyCursor-1;						while( ++i < abcContext.methodCount && ( i - abcContext.methodBodyCursor < abcContext.methodBodyLimit ) )			{				method = abcInfo.methods[i];								if( method.body != null && method.body is ABCMethodBody ) 				{										output.writeEncodedU32( i );					output.writeEncodedU32( method.body.maxStack );					output.writeEncodedU32( method.body.localCount );					output.writeEncodedU32( method.body.initScope );					output.writeEncodedU32( method.body.maxScope );					output.writeEncodedU32( method.body.codeLength );															output.writeBytes( method.body.code );															if( method.body.exceptions != null && method.body.exceptions.length > 0 ) 					{												output.writeEncodedU32( method.body.exceptions.length );												for( j = 0; j< method.body.exceptions.length; j++ ) 						{														ex = method.body.exceptions[j];														output.writeEncodedU32( ex.from );							output.writeEncodedU32( ex.to );							output.writeEncodedU32( ex.target );							output.writeEncodedU32( abcInfo.cpool.getStringIndex( ex.ectType ) );							output.writeEncodedU32( abcInfo.cpool.getStringIndex( ex.varName ) );													}					} else {						output.writeEncodedU32( 0 );					}					writeTraits( output, abcInfo, method.body );				}									        }									trace("ABCWriter: Wrote "+ (i-abcContext.methodBodyCursor) + " method bodies in " + (output.position-start) + " bytes.")						abcContext.methodBodyCursor += i-abcContext.methodBodyCursor;						}				/**		 * Method is used to read all traits_info entries for specified object.		 * Traits are defined for classes (static methods, static slots/consts), 		 * for scripts (script public/private classes, script methods, script variables)		 * and for instances (slots, consts, methods). 		 * 		 * For more information refere to : "ActionScript Virtual Machine 2 (AVM2) Overview"		 * A trait is a fixed-name property shared by all objects that are instances of 		 * the same class; a set of traits expresses the type of an object.		 *  		 * 		 * @param t - objects for which traits should be read  		 * @param abc - ABCinfo object		 * 		 */			 		private function writeTraits( output:ByteArrayOutputStream, abcInfo:ABCInfo, t:IABCTraits ):void		{			var dummy		:uint;			var name		:String;			var kind		:uint;			var id			:uint;						var i:int;			var j:int;						var trait		:*; //could be any kind of trait			var cpool		:ABCCPool = abcInfo.cpool;			var metadata	:Vector.<ABCMetaData> = abcInfo.metadata;						var traits		:Array = t.traits;						output.writeEncodedU32( traits.length );						for ( i=0; i < traits.length; i++ ) {								trait = traits[i];								// trait name ~ property name 				output.writeEncodedU32( cpool.getMultinameIndex( trait.name ) );				// trait kind 				output.writeS8( trait.kind );								// meaning depends on trait kind 				output.writeEncodedU32( trait.id );								switch( trait.kind & 0x0f ) 				{					/* primitive var & const properties */					case ABCConsts.TRAIT_Slot:					case ABCConsts.TRAIT_Const:							trait = trait as ABCTraitConstSlot;														output.writeEncodedU32( cpool.getMultinameIndex( trait.type ) );														output.writeEncodedU32( trait.vindex );							if ( trait.vindex ) 								output.writeS8( trait.vkind );						break;											/* class property this is only present for scripts ? */					case ABCConsts.TRAIT_Class:							output.writeEncodedU32( abcInfo.getClassIndex( trait as ABCClass ) );						break;					/* methods */					case ABCConsts.TRAIT_Function:					case ABCConsts.TRAIT_Method:					case ABCConsts.TRAIT_Getter:					case ABCConsts.TRAIT_Setter:							output.writeEncodedU32( abcInfo.getMethodIndex( trait as ABCMethodInfo ) );						break;				}									if ( (trait.kind >> 4) & ABCConsts.ATTR_metadata ) {										output.writeEncodedU32( trait.metadata.length );										for( j=0; j < trait.metadata.length; ++j)						output.writeEncodedU32(trait.metadata[j]);				}			}		}				/**		 * For information refer to : "ActionScript Virtual Machine 2 (AVM2) Overview"		 */		protected function defaultValue( kind : uint, idx : uint, cpool : ABCCPool ):*		{			switch ( kind )			{				case ABCConsts.CONSTANT_Utf8:   return cpool.getString(idx);				case ABCConsts.CONSTANT_UInt:				case ABCConsts.CONSTANT_Int:    return cpool.getInt(idx);				case ABCConsts.CONSTANT_UInt:   return cpool.getUInt(idx);				case ABCConsts.CONSTANT_Double: return cpool.getDouble(idx);												case ABCConsts.CONSTANT_Namespace:				case ABCConsts.CONSTANT_PrivateNs:				case ABCConsts.CONSTANT_PackageNs:				case ABCConsts.CONSTANT_PackageInternalNs:				case ABCConsts.CONSTANT_ProtectedNs:				case ABCConsts.CONSTANT_ExplicitNamespace:				case ABCConsts.CONSTANT_StaticProtectedNs: 												return cpool.getNamespace(idx);								case ABCConsts.CONSTANT_False:  return false;// { 10:false }				case ABCConsts.CONSTANT_True:   return true;// { 11:true }				case ABCConsts.CONSTANT_Null:   return null;//{ 12: null }			}			}	}}