/* * Copyright(c) 2009 Dan Riley * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.libspark.swfassist.swf.abc.opcode{	import flash.utils.ByteArray;		import org.libspark.swfassist.io.ByteArrayInputStream;		import org.libspark.swfassist.swf.abc.consts.ABCConsts;	import org.libspark.swfassist.swf.abc.structures.ABCInfo;		public class ABCOpState	{				/**		 * ABCOpState, holds the current state of a method body.		 * In the future this may be able to store stack and scope variables		 * but for now it just stores a history of the opCodes read for matching		 * in a validator. This way a validator can look at the current and previous		 * opCodes and figure out if it needs to modify the byte code in some way.		 */		 public function ABCOpState( abcInfo:ABCInfo = null, l:uint = 0 )		 {			 _abcInfo = abcInfo;			 			 length = l;		 }				private var _abcInfo:ABCInfo;		private var _length:uint = 0;		private var _history:ABCOpInfo;				public var opReader:ABCOpReader = null;				/**		 * Returns the opcode of the instruction		 * @param index - Index into the history list		 */		public function opCode( index:uint = 0 ):int		{			var opInfo:ABCOpInfo = getOpInfo( index );						if( opInfo != null )				return opInfo.opCode;							return null;		}				/**		 * Returns the values of the instruction		 * @param index - Index into the history list		 */		public function value( index:uint = 0 ):Vector.<int>		{			var opInfo:ABCOpInfo = getOpInfo( index );						if( opInfo != null )				return opInfo.value;							return null;		}				/**		 * Returns the position in the byte array of the start of the opcode		 * @param index - Index into the history list		 */		public function start( index:uint = 0 ):uint		{			var opInfo:ABCOpInfo = getOpInfo( index );						if( opInfo != null )				return opInfo.start;							return null;		}				/**		 * Returns the position in the byte array of the end of the opcode values		 * @param index - Index into the history list		 */		public function end( index:uint = 0 ):uint		{			var opInfo:ABCOpInfo = getOpInfo( index );						if( opInfo != null )				return opInfo.end;							return null;		}				/**		 * Returns a state object at a specified history		 * @param index - Index into the history list		 */		private function getOpInfo( index:uint = 0 ):ABCOpInfo		{			var opInfo:ABCOpInfo = _history;			while( index-- > 0 )				opInfo = opInfo.next;							return opInfo;		}				public function get abcInfo():ABCInfo		{			return _abcInfo;		}				public function set abcInfo( abc:ABCInfo ):void		{			_abcInfo = abc;		}				/**		 * Clears the history data but keeps the nodes connected		 */		public function clear():void		{			if( _history )			{				var opInfo:ABCOpInfo = _history;				while( opInfo.next != null )				{					opInfo.clear();					opInfo = opInfo.next;				}			}						_abcInfo = null;		}				/**		 * Dynamically alters the length of the history. Objects are added		 * if the length is increased or disposed if it is decreased.		 */		public function set length( l:uint ):void		{			var oldOpInfo:ABCOpInfo;			var lastOpInfo:ABCOpInfo;			var i:int = 0;						// Init linked list			if( l > 0 && _history == null ) {				_history = new ABCOpInfo();			}			lastOpInfo = _history;						var max:uint = Math.max( l, _length );			while( ++i < max )			{				if( i < l )				{					// Adding					if( lastOpInfo.next == null )						lastOpInfo.next = new ABCOpInfo();											lastOpInfo = lastOpInfo.next;									} else {					// Removing					oldOpInfo = lastOpInfo;					lastOpInfo = lastOpInfo.next;										oldOpInfo.dispose();				}			}						if( l == 0 )			{				_history.dispose();				_history = null;			}			_length = l;					}				public function get length():uint		{			return _length;		}				/**		 * Reads the next available opcode		 */		public function read( opReader:ABCOpReader ):void		{			opReader.read();						// Pop the oldest history element off the list			var oldest:ABCOpInfo = _history;			while( oldest.next != null ) {				if( oldest.next.next == null )				{					var temp:ABCOpInfo = oldest.next;					oldest.next = null;					oldest = temp;					break;				} else {					oldest = oldest.next;				}			}			// Fill it with the new data and set it as the first item			if( _length > 1 ) {				oldest.next = _history;				_history = oldest;			}							_history.opCode = opReader.opCode;			_history.value = opReader.value;			_history.start = opReader.start;			_history.end = opReader.position;		}	}}internal class ABCOpInfo{	public var start:uint = 0;	public var end:uint = 0;	public var opCode:int;	public var value:Vector.<int>;	public var next:ABCOpInfo = null;		public function clear()	{		opCode = 0;		value = null;		start = 0;		end = 0;	}		public function dispose()	{		clear();		next = null;	}}