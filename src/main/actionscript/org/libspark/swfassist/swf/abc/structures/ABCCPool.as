/* * The Spark Project ( http://libspark.org ) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. * * The Original Code is [Open Source Virtual Machine.]. * * The Initial Developer of the Original Code is Adobe System Incorporated. * Portions created by the Initial Developer are Copyright (C) 2004-2006 * the Initial Developer. All Rights Reserved. * * Contributor(s): * * Adobe AS3 Team * Mateusz Malczak ( http://segfaultlabs.com ) * Daniel Riley	 ( http://scientificsciences.com ) */package org.libspark.swfassist.swf.abc.structures{	import org.libspark.swfassist.errors.ErrorHandler;	import org.libspark.swfassist.errors.ErrorIdConstants;	import org.libspark.swfassist.errors.ErrorMessageConstants;	import org.libspark.swfassist.errors.Warning;		import org.libspark.swfassist.swf.abc.consts.ABCConsts;		/**	 * Constant pool for a single swf file. This object stores all constants 	 * values that are refered from doABC tag. Constant pool content is common 	 * for all doABC blocks that are present in SWF file. 	 *	 * The first index into each number array (int, uint, and double) is null, 0	 * or NaN.	 *   	 * @author malczak	 * @author danriley	 * @version 0.2	 */		public final class ABCCPool	{		public var ints			:Vector.<int>;		public var uints		:Vector.<uint>;		public var doubles		:Vector.<Number>;		public var strings		:Vector.<String>;		public var namespaces	:Vector.<ABCNamespace>;		public var nssets		:Vector.<ABCNamespaceSet>;		public var names		:Array;							public function ABCCPool():void		{			ints = null; 			uints = null; 			doubles = null; 			strings = null; 			namespaces = null; 			names = null; 		}				private function error( id:uint, message:String = ''):void		{			var e:Error = new Error(message, id);			throw e;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numInts():uint 		{			if( ints == null || ints.length <= 1 )				return 0;			else				return ints.length;		}				/**		 * Initializes the integer pool, the first value being the default of 0		 */		public function initInts():uint		{			if( ints == null )			{				ints = new Vector.<int>();				ints[0] = 0;			}							return ints.length;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numUInts():uint 		{			if( uints == null || uints.length < 2 )				return 0;			else				return uints.length;		}				/**		 * Initializes the unsigned integer pool, the first value being the default of 0		 */		public function initUInts():uint		{			if( uints == null )			{				uints = new Vector.<uint>();				uints[0] = 0;			}							return uints.length;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numDoubles():uint 		{			if( doubles == null || doubles.length < 2 )				return 0;			else				return doubles.length;		}				/**		 * Initializes the integer pool, the first value being the default of NaN		 */		public function initDoubles():uint		{			if( doubles == null )			{				doubles = new Vector.<Number>();				doubles[0] = NaN;			}							return doubles.length;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numStrings():uint 		{			if( strings == null || strings.length < 2 )				return 0;			else				return strings.length;		}				/**		 * Initializes the string pool, the first value being the default of an empty string		 */		public function initStrings():uint		{			if( strings == null )			{				strings = new Vector.<String>();				strings[0] = "";			}							return strings.length;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numNamespaces():uint 		{			if( namespaces == null || namespaces.length < 2 )				return 0;			else				return namespaces.length;		}				/**		 * Initializes the namespace pool, the first value being the default of an 'all' selector		 */		public function initNamespaces():uint		{			if ( namespaces == null ) 			{				namespaces = new Vector.<ABCNamespace>();				namespaces[0] = new ABCNamespace(ABCConsts.CONSTANT_Namespace, "*");			}						return namespaces.length;		}				/**		 * Returns the length of the cpool for this type to be written to a file (length - 1)		 */		public function get numNSSets():uint 		{			if( nssets == null || nssets.length < 2 )				return 0;			else				return nssets.length;		}				/**		 * Initializes the namespace set pool, the first value being the default of null		 */		public function initNSSets():uint		{			if ( nssets == null ) {				nssets = new Vector.<ABCNamespaceSet>();				nssets[0] = null;			}						return nssets.length;		}		/**		 * Returns the length of the cpool for this type to be written to a file (length - 1), the 0 index is ignored		 */		public function get numMultinames():uint 		{			if( names == null || names.length < 2 )				return 0;			else				return names.length;		}				/**		 * Initializes the multiname pool, the first value being the default of 'all'		 */		public function initMultinames():uint		{			if ( names == null )				names = [ new ABCMultinameInfo( ABCConsts.CONSTANT_Qname, new ABCMultinameQName( namespaces[0], "*") ) ];							return names.length;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getInt( index:int ):int		{			if( index > -1 && index < ints.length )				return ints[index];			else				error( ErrorIdConstants.INVALID_CPOOLINDEX, ErrorMessageConstants.INVALID_CPOOLINDEX);							return 0;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getUInt( index:int ):uint		{			if( index > -1 && index < uints.length )				return uints[index];			else				error( ErrorIdConstants.INVALID_CPOOLINDEX, ErrorMessageConstants.INVALID_CPOOLINDEX);							return 0;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getDouble( index:int ):Number		{			if( index > -1 && index < doubles.length )				return doubles[index];			else				error( ErrorIdConstants.INVALID_CPOOLINDEX, ErrorMessageConstants.INVALID_CPOOLINDEX);							return 0;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getString( stringIndex:int ):String		{			if( stringIndex > -1 && stringIndex < strings.length )				return strings[stringIndex];			else				error( ErrorIdConstants.INVALID_ABCSTRING, ErrorMessageConstants.INVALID_ABCSTRING);							return null;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getNamespace( namespaceIndex:int ):ABCNamespace		{			if( namespaceIndex > -1 && namespaceIndex < namespaces.length )				return namespaces[namespaceIndex];			else				error( ErrorIdConstants.INVALID_NAMESPACE, ErrorMessageConstants.INVALID_NAMESPACE);							return null;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getNSSet( nssetIndex:int ):ABCNamespaceSet		{			if( nssetIndex > -1 && nssetIndex < nssets.length )				return nssets[nssetIndex];			else				error( ErrorIdConstants.INVALID_NAMESPACESET, ErrorMessageConstants.INVALID_NAMESPACESET);							return null;		}				/**		 * Returns the item from the pool, or throws an error if the index is out of bounds		 */		public function getMultiname( nameIndex:int ):ABCMultinameInfo		{			if( nameIndex > -1 && nameIndex < names.length )				return names[nameIndex];			else				error( ErrorIdConstants.INVALID_MULTINAME, ErrorMessageConstants.INVALID_MULTINAME);							return null;		}				/**		 * Returns the index into the pool where the item exists, or throws an error if it does not exist		 */		public function getNamespaceIndex( ns:ABCNamespace ):int 		{			var nameidx:int = namespaces.indexOf( ns );											if( nameidx == -1 )				error( ErrorIdConstants.INVALID_NAMESPACE, ErrorMessageConstants.INVALID_NAMESPACE);						return nameidx;		}				/**		 * Returns the index into the pool where the item exists, or throws an error if it does not exist		 */		public function getNSSetIndex( nsset:ABCNamespaceSet ):int		{				var nsidx:int = nssets.indexOf( nsset );											if( nsidx == -1 )					error( ErrorIdConstants.INVALID_NAMESPACESET, ErrorMessageConstants.INVALID_NAMESPACESET);									return nsidx;		}				/**		 * Returns the index into the pool where the item exists, or throws an error if it does not exist		 */		public function getMultinameIndex( m:ABCMultinameInfo ):int 		{			var nameidx:int = names.indexOf( m );											if( nameidx == -1 )				error( ErrorIdConstants.INVALID_MULTINAME, ErrorMessageConstants.INVALID_MULTINAME);						return nameidx;		}				/**		 * Returns the index into the pool where the item exists, or throws an error if it does not exist		 */		public function getStringIndex( str:String, ignoreZeroIndex:Boolean = true ):int 		{			var nameidx:int = strings.indexOf( str, ignoreZeroIndex ? 1 : 0 );			if( nameidx == -1 )				if( str == "" || str == "*" )					return 0;				else					error( ErrorIdConstants.INVALID_ABCSTRING, ErrorMessageConstants.INVALID_ABCSTRING);							return nameidx;		}				/**		 * 'Release' used memory. You should always call this method when parsing has finished, and 		 *  no more doABC blocks will be parsed. 		 * 		 */				public function dispose():void		{			ints = null; 			uints = null; 			doubles = null; 			strings = null; 			namespaces = null; 			names = null; 			nssets = null;		}	}}