/* * The Spark Project ( http://libspark.org ) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. * * The Original Code is [Open Source Virtual Machine.]. * * The Initial Developer of the Original Code is Adobe System Incorporated. * Portions created by the Initial Developer are Copyright (C) 2004-2006 * the Initial Developer. All Rights Reserved. * * Contributor(s): * * Adobe AS3 Team * Mateusz Malczak ( http://segfaultlabs.com ) * Daniel Riley	 ( http://scientificsciences.com ) */package org.libspark.swfassist.swf.abc.structures{		import org.libspark.swfassist.errors.ErrorHandler;	import org.libspark.swfassist.errors.ErrorIdConstants;	import org.libspark.swfassist.errors.ErrorMessageConstants;	import org.libspark.swfassist.errors.Warning;		import flash.utils.ByteArray;	import flash.utils.Endian;		/**	 * This class is an easy to read representation of code from parsed doABC tag. Single	 * doABC tag (ABCInfo) can store information about many classes used in SWF. In Action 	 * Script 3 each class is always defined in a seperate source file, called 'script'.	 * Each script can have only one externally visible class, function or variable.	 * Beside single public definition, script can store a numer of internal (script private)	 * objects (classes, functions or variables). This can be presented as a following structure :	 * <listing> 	 *	+---------  	 *	| Script 	 *  |  +-------- 	 *  |  |package  	 *	|  | +------- 	 *	|  | |public resource (class / function / variable) 	 *	|  | +------- 	 *	|  +-------- 	 *	|  +-------- 	 *	|  | internal classes 	 *	|  +-------- 	 *	+--------- 	 * </listing> 	 * Where single class (both public and internal) is build of namespaced properties and methods: 	 * <listing>  	 *	+------------- 	 *	| Class 	 *	|  +------- 	 *	|  | static data (properties, methods) 	 *	|  +------- 	 *	|  +------- 	 *	|  | class instance (object) data 	 *	|   +-------	 *  +-------------	 * </listing>	 * 	 * For more informationa refer to : 	 * <ul>	 * 	<li> ActionScript Virtual Machine 2 (AVM2) Overview </li>	 *  <li> Programming Action Script 3.0 </li>	 * 	<li> Tamarin project (http://www.mozilla.org/projects/tamarin/) </li>	 * </ul>	 * @author malczak	 * @version 0.2	 * 	 */		final public class ABCInfo		{		public var major	:int;		public var minor	:int;		public var target	:String;					/* abc info */		public var methods  	:Vector.<ABCMethodInfo>;		public var metadata 	:Vector.<ABCMetaData>;		private var _instances	:Vector.<ABCInstance>;		private var _classes  	:Vector.<ABCClass>;		private var _scripts  	:Vector.<ABCTraits>;				private var _cpool 	:ABCCPool;					public function ABCInfo():void		{			methods = null; 			metadata = null; 			instances = null; 			classes = null; 			scripts = null;		}				public function get cpool():ABCCPool		{			if( _cpool == null )				_cpool = new ABCCPool();							return _cpool;		}				public function set cpool( p:ABCCPool )		{			_cpool = p;		}				public function get instances():Vector.<ABCInstance>		{			if( _instances == null )				_instances = new Vector.<ABCInstance>();							return _instances;		}				public function set instances( value:Vector.<ABCInstance> )		{			_instances = value;		}				public function get classes():Vector.<ABCClass>		{			if( _classes == null )				_classes = new Vector.<ABCClass>();							return _classes;		}				public function set classes( value:Vector.<ABCClass> )		{			_classes = value;		}				public function get scripts():Vector.<ABCTraits>		{			if( _scripts == null )				_scripts = new Vector.<ABCTraits>();							return _scripts;		}				public function set scripts( value:Vector.<ABCTraits> )		{			_scripts = value;		}				private function error( id:uint, message:String = ''):void		{			var e:Error = new Error(message, id);			throw e;		}				public function getMethod( i:int ):ABCMethodInfo		{			if( i > -1 && i < methods.length )			{				return methods[i];			} else {				error( ErrorIdConstants.INVALID_METHOD, ErrorMessageConstants.INVALID_METHOD);			}						return null;		}				public function getClass( i:int ):ABCClass		{			if( i > -1 && i < _classes.length )			{				return _classes[i];			} else {				error( ErrorIdConstants.INVALID_CLASS, ErrorMessageConstants.INVALID_CLASS);			}						return null;		}				public function getInstance( i:int ):ABCInstance		{			if( i > -1 && i < _instances.length )			{				return _instances[i];			} else {				error( ErrorIdConstants.INVALID_INSTANCE, ErrorMessageConstants.INVALID_INSTANCE);			}						return null;		}				public function getMethodIndex( m:ABCMethodInfo ) 		{			var midx:int = methods.indexOf( m );											if( midx == -1 )				error( ErrorIdConstants.INVALID_METHOD, ErrorMessageConstants.INVALID_METHOD);						return midx;		}				public function getClassIndex( c:ABCClass ) 		{			var cidx:int = classes.indexOf( c );											if( cidx == -1 )				error( ErrorIdConstants.INVALID_CLASS, ErrorMessageConstants.INVALID_CLASS);						return cidx;		}				/**		 * 'Release memory', remove all stored inforamtion  		 */		public function dispose():void		{			var i	:uint;			var mth	:ABCMethodInfo;			var inst:ABCInstance;			var cls	:ABCClass;			var str	:ABCTraits;						for each ( mth in methods )								{				if ( mth.body && mth.body.code )  				{					mth.body.code.length = 0;					mth.body.code = null;				}			}						for each ( inst in instances )  			{				inst.classRef = null;				inst.traits.length = 0;				inst.init = null;	 			}						for each ( cls in classes ) 			{				cls.instanceRef = null;				cls.scriptRef = null;				cls.init = null;				cls.traits.length = 0;			}						for each ( str in scripts ) 			{				str.init = null;				str.traits.length = 0;			}							methods.length = 0;			methods = null;						instances.length = 0;			instances = null;						classes.length = 0;			classes = null;						scripts.length = 0;			scripts = null;						metadata.length = 0; 			metadata = null;		}	}    }