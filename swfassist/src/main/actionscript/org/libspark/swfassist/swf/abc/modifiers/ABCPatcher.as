/* * Copyright(c) 2009 Dan Riley * Copyright(c) 2007 the Spark project. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *     http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,  * either express or implied. See the License for the specific language * governing permissions and limitations under the License. */package org.libspark.swfassist.swf.abc.modifiers{	import flash.events.Event;	import flash.display.Shape; //for enter_frame	import flash.utils.ByteArray;	import flash.utils.Endian;		import org.libspark.swfassist.utils.BitwiseUtil;		import org.libspark.swfassist.swf.abc.opcode.ABCOpReader;	import org.libspark.swfassist.swf.abc.opcode.ABCOpState;	import org.libspark.swfassist.swf.abc.opcode.ABCPatch;	import org.libspark.swfassist.swf.abc.opcode.ABCControlTransfer;	import org.libspark.swfassist.swf.abc.validators.IABCValidator;		import org.libspark.swfassist.swf.tags.AbstractTagVisitor;		//Dan	import org.libspark.swfassist.io.ByteArrayInputStream;	import org.libspark.swfassist.io.ByteArrayOutputStream;	import org.libspark.swfassist.swf.tags.DoABC;		import org.libspark.swfassist.swf.abc.consts.ABCConsts;	import org.libspark.swfassist.swf.abc.structures.ABCClass;		import org.libspark.swfassist.swf.abc.structures.ABCInfo;	import org.libspark.swfassist.swf.abc.structures.ABCInstance;	import org.libspark.swfassist.swf.abc.structures.ABCMethodInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMethodBody;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameInfo;	import org.libspark.swfassist.swf.abc.structures.ABCMultinameQName;	import org.libspark.swfassist.swf.abc.structures.ABCTraits;	import org.libspark.swfassist.swf.abc.structures.ABCTraitConstSlot;	import org.libspark.swfassist.swf.abc.structures.ABCTraitsInfo;	import org.libspark.swfassist.swf.abc.structures.ABCExceptionInfo;		import org.libspark.swfassist.swf.abc.io.ABCReader;	import org.libspark.swfassist.swf.abc.io.ABCWriter;	import org.libspark.swfassist.swf.abc.io.ABCContext;		import org.libspark.swfassist.swf.abc.io.ABCReadingContext;	import org.libspark.swfassist.swf.abc.io.ABCWritingContext;				public class ABCPatcher extends AbstractTagVisitor	{		/**		 * This class goes through each method and finds areas that		 * are in need of patching based off a supplied validation		 * method. Patches are stored in an array, and then patched		 * on completion of inspection. Insertion and removal of code		 * requires that surrounding Control Transfers (if/for/switch, etc.)		 * be modified if they encapsulate the patch.		 * 		 * The method code length will need to updated as well as		 * Exception offsets also need to be modified.		 *		 * This is also designed with the idea of multiple ABCTags in		 * mind. However we have not yet encountered this so don't know		 * if that aspect will work.		 *		 * @param validator The validator is a class with a validate function that		 * @param timeLimit The maximum amount of time per frame for reading and writing operations		 * @param patchLimit The maximum amount of methods to patch per frame		 * reads opcodes and decides what to do with them.		 */		 		public function ABCPatcher( validator:IABCValidator, timeLimit:uint = 0, patchLimit:uint = 0, onComplete:Function = null )		{			_validator = validator;			_timeLimit = timeLimit == 0 ? uint.MAX_VALUE : timeLimit;			_patchLimit = patchLimit == 0 ? uint.MAX_VALUE : patchLimit;			_onComplete = onComplete;						// For reading opCodes			_opState = new ABCOpState( null, _validator.historyLength );			_opReader = new ABCOpReader();		}						private var _thread:Shape;		private var _onComplete:Function;				public var reader:ABCReader;		public var writer:ABCWriter;		public var readerContext:ABCReadingContext;		public var writerContext:ABCWritingContext;				public var input:ByteArrayInputStream;		public var output:ByteArrayOutputStream;				private var _opState:ABCOpState;		private var _opReader:ABCOpReader;				private var _timeLimit:uint = 0;		private var _patchLimit:uint = 0;				private var _abcInfo:ABCInfo;		private var _validator:IABCValidator;		private var _tags:Vector.<DoABC>; 		// List of tags to be patched		private var _tag:uint = 0;				// Current tag index		private var _numTags:uint = 0;			// Number of tags to patch		private var _numTagsComplete:uint = 0; 	// Number of tags already patched				private var _methodIndex:uint = 0;		// The current method being patched				/**		 * Called once for every doABC tag, the tag is stored in an array		 * and each is patched after eachother		 */		public override function visitDoABC( tag:DoABC ):void		{			// Initialization			if( _tags == null )			{				_tags = new Vector.<DoABC>();				_numTags = 0;				_numTagsComplete = 0;			}						// Add the tag to a list of tags to process			_tags[ _numTags++ ] = tag;						// Process the first tag			if( _numTags == 1 )				patchNextTag();		}				private function patchNextTag():void		{			var tag:DoABC = _tags[ _tag ];						reader = new ABCReader();			writer = new ABCWriter();			readerContext = new ABCReadingContext();			writerContext = new ABCWritingContext();						input = new ByteArrayInputStream(tag.abcData);			input.position = 0;						output = new ByteArrayOutputStream();						_abcInfo = new ABCInfo();			_methodIndex = 0;			readerContext.methodBodyLimit = 500; //Read 500 method bodies per frame			writerContext.methodBodyLimit = 500; //Write 500 method bodies per frame						// Start thread to read ABC, patch, and then write			if( _thread == null )				_thread = new Shape();							_thread.addEventListener(Event.ENTER_FRAME, readHandler);		}				private function patchComplete():void		{						// Done patching methods			// Set the abcTag bytecode to the patched bytecode			output.position = 0;			_tags[_tag].abcData = output.byteArray;									if( ++_tag == _numTags )			{				if( _onComplete != null )					_onComplete();			} else {				patchNextTag();			}		}				private function readHandler(e:Event):void		{						reader.readABC( input, readerContext, _abcInfo, _timeLimit );					if( readerContext.cursor == ABCContext.CURSOR_COMPLETE ) 			{				_thread.removeEventListener(Event.ENTER_FRAME, readHandler);				_thread.addEventListener(Event.ENTER_FRAME, patchHandler);			}		}		private function patchHandler( evt:Event )		{			patchMethods( _patchLimit );						if( _methodIndex == _abcInfo.methods.length )			{				_thread.removeEventListener(Event.ENTER_FRAME, patchHandler );				_thread.addEventListener(Event.ENTER_FRAME, writeHandler );			}		}				private function writeHandler( evt:Event )		{			writer.writeABC( output, writerContext, _abcInfo, _timeLimit );					if( writerContext.cursor == ABCContext.CURSOR_COMPLETE ) 			{				patchComplete();				_thread.removeEventListener(Event.ENTER_FRAME, writeHandler);			}		}				/**		 * patchMethods goes through each method and gathers a Vector of every		 * area in the byteCode that needs to be 'patched' or changed, it stores		 * the number of bytes to remove, and the bytes to add in each area as		 * an ABCPatch object. Every time a control transfer area is encountered		 * it is also recorded (anywhere that the code is non-linear, such as		 * a jump or an if statement. If patches are found, then the code goes		 * through and patches each object, if it results in a change in length		 * of that area, then control transfers surrounding that area need to be		 * updated, along with exceptions, and the total length of the code.		 */		private function patchMethods( methodLimit:uint = 0 )		{						var p:int = -1;			var e:int = -1;			var t:int = -1;						var numMethods:int = _abcInfo.methods.length;			var exception	:ABCExceptionInfo;			var method		:ABCMethodInfo;			var body		:ABCMethodBody;						var patches:Vector.<ABCPatch> = new Vector.<ABCPatch>();			var transfers:Vector.<ABCControlTransfer> = new Vector.<ABCControlTransfer>();			var numPatches:int = 0;			var numTransfers:int = 0;			var numExceptions:int = 0;			var updateTransfers:Boolean = false;						var buffer:ByteArray;			var output:ByteArrayOutputStream = new ByteArrayOutputStream();						var i:int = _methodIndex-1;						if( methodLimit == 0 ) {				methodLimit = uint.MAX_VALUE;			}						while( ++i < numMethods && ( i-_methodIndex < methodLimit ) )			{				method = _abcInfo.methods[i];								findPatches( _abcInfo, method, patches, transfers );								numPatches = patches.length;				if( numPatches > 0 )				{					body = method.body;					var codeLength:uint = body.codeLength;										numTransfers = transfers.length;					numExceptions = body.exceptions.length;										trace( "Found " + numPatches + " patches in method." );					trace( "Found " + numTransfers + " transfers in method." );										// Allocate a byte array for the buffer					buffer = new ByteArray();					buffer.endian = Endian.LITTLE_ENDIAN;					var dif:int;					var totalDif:int = 0;										p = -1;					while( ++p < numPatches )					{						dif = patches[p].difference;						totalDif += dif;												// Update control transfers						t = -1;						while( ++t < numTransfers )						{							if(transfers[t].inside(patches[p].location))							{								updateTransfers = true;								trace("Patch is inside transfer");								transfers[t].expand( dif );																transfers[t].updated = true;							}						}												// Update exceptions						e = -1;						while( ++e < numExceptions )						{							exception = body.exceptions[e];							if( patches[p].location > exception.from )							{								if( patches[p].location < exception.to )									exception.to += dif;								if( patches[p].location < exception.target )									exception.target += dif;							}						}											}										// Update all of the transfer offsets in the byte array					if( updateTransfers )					{						output.byteArray = body.code;						output.resetBitCursor();												t = -1;						while( ++t < numTransfers )						{														if( transfers[t].updated )							{								trace("updating " + t ); 								output.position = transfers[t].location;								output.writeS24( transfers[t].offset );							}						}					}																									body.code.position = 0;					var bufferPos:int = 0;					var offset:int = 0;					p = -1;					while( ++p < numPatches )					{						offset = patches[p].location-body.code.position;						//Write the buffer up until this patch						body.code.readBytes( buffer, bufferPos, offset );												bufferPos += offset;												if( patches[p].byteArray != null )						{							patches[p].byteArray.readBytes( buffer, bufferPos );							bufferPos += patches[p].numBytesAdded;						}													//skip over the deleted bytes						body.code.position += patches[p].numBytesRemoved;					}					//Write the rest of the buffer					body.code.readBytes( buffer, bufferPos);															// Update the total difference of the method body					codeLength += totalDif;										trace("patched to buffer new length: " + buffer.length + " old length: " + body.code.length + " guessed length: " + codeLength);										body.code.clear();					body.code = buffer;					trace("final length " + body.codeLength );				}								// Reset vectors				patches.length = 0;				transfers.length = 0;			}												trace("ABCInfoPatcher: Patched " + (i-_methodIndex) + " methods.");			_methodIndex += (i-_methodIndex);		}						/**		 * findPatches takes the ABCInfo, the method, and validates them using		 * the current validator function		 */		public function findPatches( abcInfo:ABCInfo, method:ABCMethodInfo, patches:Vector.<ABCPatch>, transfers:Vector.<ABCControlTransfer>):Boolean		{			if (method.body == null)				return false;			_opState.clear();			_opState.abcInfo = abcInfo;						_opReader.clear();			_opReader.byteArray = method.body.code;						var patch:ABCPatch = new ABCPatch();			var transfer:ABCControlTransfer = new ABCControlTransfer();			var numPatches:int = 0;			var numTransfers:int = 0;						while (_opReader.bytesAvailable > 0) 			{				// Read the next available opcode and store it in the state history				_opState.read( _opReader );				// Check if the current code is a control				// transfer, if so record it				if( _opReader.controlTransfer )				{					//If it is a switch statement it is a special case					if( _opReader.opCode == ABCConsts.OP_lookupswitch )					{						// Make a transfer object for the default case						transfer.location = _opReader.start+1;						transfer.base = _opReader.start;						transfer.offset = _opReader.value[0];						transfers[numTransfers++] = transfer;						transfer = new ABCControlTransfer();													// Make a transfer object for each switch state						var numCases:int = _opReader.value[1];												// Position of instruction is opcode + S24 (default case) + EU32 (numCases)						var numBits:uint = uint(BitwiseUtil.getMinBits(numCases)/7)+1;						var position:int = _opReader.start+4+numBits;						var i:int = -1;						while( ++i <= numCases )						{							transfer.location = position + i*3;							transfer.base = _opReader.start;							transfer.offset = _opReader.value[2+i];							transfers[numTransfers++] = transfer;							transfer = new ABCControlTransfer();						}											} else {												transfer.location = transfer.base = _opReader.start+1;						transfer.offset = _opReader.value[0];						transfers[numTransfers++] = transfer;						transfer = new ABCControlTransfer();					}									}				// Check if it needs to be patched, if so, generate				if(_validator.validate(_opState, patch))				{					patches[numPatches++] = patch;					patch = new ABCPatch();				} 							}						return true;		}					}}